package Logic;

import java.util.ArrayList;
import java.util.List;

public class Move {

	public int startPointX;
	public int startPointY;
	public int endPointX;
	public int endPointY;
	public int valueOfMove;

	final int BLACKPIECE = -1;
	final int WHITEPIECE = 1;
	final int EMPTYSPOT = 0;

	public Move(int startX, int startY, int endX, int endY) {

		startPointX = startX;
		startPointY = startY;
		endPointX = endX;
		endPointY = endY;
		valueOfMove = 0;
	}

	public Move() {

		startPointX = 0;
		startPointY = 0;
		endPointX = 0;
		endPointY = 0;
		valueOfMove = 0;
	}

	// Copy constructor
	public Move(Move other) {

		this.startPointX = other.startPointX;
		this.startPointY = other.startPointY;
		this.endPointX = other.endPointX;
		this.endPointY = other.endPointY;
		this.valueOfMove = other.valueOfMove;

	}

	public int[][] newMove(int[][] gameBoard) {
		// TODO Auto-generated method stub
		return null;
	}

	public boolean isOneStepMove() {
		int xDiff = endPointX - startPointX;
		int yDiff = endPointY - startPointY;
		if (-2 < xDiff && xDiff < 2 && -2 < yDiff && yDiff < 2)
			return true;
		
		return false;
	}

	/**
	 * removes all out of board points as well and returns effective points
	 * 
	 * @param currentPoint
	 * @param maxRow
	 * @param maxCol
	 * @return
	 */
	public List<Point> getAdjPoints(Point currentPoint, int maxRow, int maxCol) {
		List<Point> adjacentPoints = new ArrayList<Point>();
		adjacentPoints.add(new Point(currentPoint.x, currentPoint.y + 1));
		adjacentPoints.add(new Point(currentPoint.x, currentPoint.y - 1));
		adjacentPoints.add(new Point(currentPoint.x + 1, currentPoint.y));
		adjacentPoints.add(new Point(currentPoint.x - 1, currentPoint.y));
		// diagonals
		if (isDiagonalMovesPossible(currentPoint)) {
			adjacentPoints
					.add(new Point(currentPoint.x + 1, currentPoint.y + 1));
			adjacentPoints
					.add(new Point(currentPoint.x + 1, currentPoint.y - 1));
			adjacentPoints
					.add(new Point(currentPoint.x - 1, currentPoint.y + 1));
			adjacentPoints
					.add(new Point(currentPoint.x - 1, currentPoint.y - 1));
		}
		List<Point> updatedAdjList = new ArrayList<Point>();
		for (Point p : adjacentPoints) {
			if (p.isValidPoint(maxRow, maxCol)) {
				updatedAdjList.add(p);
			}
		}
		return updatedAdjList;
	}

	private Boolean isDiagonalMovesPossible(Point currentPoint) {// {{{
		// (odd,odd) or (even,even)
		return (currentPoint.x % 2 == 1 && currentPoint.y % 2 == 1)
				|| (currentPoint.x % 2 == 0 && currentPoint.y % 2 == 0);
	}
}
