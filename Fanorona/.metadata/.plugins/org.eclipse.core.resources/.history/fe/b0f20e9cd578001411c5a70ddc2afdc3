package Logic;

import java.util.ArrayList;
import java.util.List;

public class Engine {

	private final int smallBoard = 3;
	private final int largeBoard = 5;
	private int[][] boardState;
	BoardProperties bP = BoardProperties.getInstance();

	public Engine() {

	}

	public Color getOtherColor(String input) {
		if (input.equals(Color.WHITE))
			return Color.BLACK;
		else
			return Color.WHITE;
	}

	public int getColorInInt(Color input) {
		if (input.equals(Color.WHITE))
			return +1;
		else
			return -1;
	}

	public void initializeBoard(int sizeOfBoard, String playerColor) {
		if (sizeOfBoard == 1) {
			bP.setMAX_COL(smallBoard);
			bP.setMAX_ROW(smallBoard);
			bP.setCompColor(getOtherColor(playerColor));
			bP.setPlayerColor(getOtherColor(bP.getCompColor().toString()));

		} else {
			bP.setMAX_COL(largeBoard);
			bP.setMAX_ROW(largeBoard);

		}
		if (playerColor.equals(Color.WHITE.toString())) {
			bP.setPlayerColor(Color.WHITE);
			bP.setCompColor(getOtherColor(playerColor));
		} else {
			bP.setPlayerColor(Color.BLACK);
			bP.setCompColor(getOtherColor(playerColor));
		}
		boardState = new int[bP.getMAX_ROW()][bP.getMAX_COL()];
		boolean flip = false;
		for (int i = 0; i < bP.getMAX_ROW(); i++) {
			for (int j = 0; j < bP.getMAX_COL(); j++) {
				if (i < (bP.getMAX_ROW() / 2)) {
					boardState[i][j] = +1;
				} else if (i > (bP.getMAX_ROW() / 2)) {
					boardState[i][j] = -1;
				} else if (i == bP.getMAX_ROW() / 2 && i != j && flip) {
					boardState[i][j] = -1;
					if (flip)
						flip = false;
					else
						flip = true;
				} else if (i != j) {
					boardState[i][j] = +1;
				} else {
					boardState[i][j] = 0;
				}
			}
		}
	}

	public int evaluateFunction(int[][] gameState) {
		int value = 0;

		for (int x = 0; x < bP.getMAX_ROW(); x++) {
			for (int y = 0; y < bP.getMAX_COL(); y++) {
				if (gameState[x][y] == 1)
					value++;
				if (gameState[x][y] == -1)
					value--;
			}
		}
		return value;
	}

	public boolean checkGameOver(int[][] boardState) {
		int blackPieces = 0;
		int whitePieces = 0;
		for (int i = 0; i < this.bP.getMAX_ROW(); i++) {
			for (int j = 0; j < this.bP.getMAX_COL(); j++) {
				if (boardState[i][j] == -1) {
					blackPieces++;
				} else if (boardState[i][j] == +1) {
					whitePieces++;
				}
			}
		}
		if (whitePieces == 0 | blackPieces == 0) {
			return true;
		} else
			return false;

	}

	/*
	 * private void placePiecesOnBoard() {
	 * 
	 * }
	 */

	public static void main(String[] args) {
		Engine e = new Engine();
		System.out.println(e.bP.getMAX_COL());

	}

	public int[] getAllPossiblePositions() {

		return null;

	}

	public void printCurrestStateOfBoard() {
		for (int i = 0; i < bP.getMAX_ROW(); i++) {
			for (int j = 0; j < bP.getMAX_COL(); j++) {
				System.out.print(boardState[i][j]);
			}
			System.out.println("\n");
		}
	}

	public int[][] makeAMove(Color playerColor, Move move) {
		if (move.isOneStepMove()) {
			// Kill computer pieces and apply alpha beta.
			updatedBoard(boardState, move, playerColor,
					getOtherColor(playerColor.toString()));
			AlphaBeta ab = new AlphaBeta(playerColor);
			Move minimax = ab.minimax(boardState);
			return updatedBoard(boardState, minimax, playerColor, playerColor);
		} else {
			System.out.println("Invalid Move Dude!!");
		}

		return null;
	}

	private int[][] updatedBoard(int[][] boardState, Move move,
			Color playerColor, Color colorToKill) {
		boardState[move.startPointX][move.startPointY] = 0;
		if (playerColor.equals(Color.BLACK))
			boardState[move.endPointX][move.endPointY] = -1;
		else
			boardState[move.endPointX][move.endPointY] = +1;
		// TODO Auto-generated method stub
		killPiecesAndUpdateBoard(boardState, move, true,
				getColorInInt(colorToKill));
		return boardState;
	}

	public void killPiecesAndUpdateBoard(int[][] boardState, Move move,
			boolean isApproachMove, int colorToKill) {
		String typeOfKill;
		int xDiff = move.endPointX - move.startPointX;
		int yDiff = move.endPointY - move.startPointY;
		BoardProperties boardInstance = BoardProperties.getInstance();
		int maxY = boardInstance.getMAX_COL();
		int maxX = boardInstance.getMAX_ROW();
		// moved up and Approach or withdrawal capture.
		int playerColor = boardInstance.getPlayerColorInInt();
		int tempX = move.endPointX;
		int tempY = move.endPointY;
		List<Point> piecesKilled = new ArrayList<Point>();
		if (isApproachMove) {
			tempX = tempX + xDiff;
			tempY = tempY + yDiff;
		} else {
			tempX = tempX - xDiff;
			tempY = tempY - yDiff;
		}
		boolean killStart=false;
		if ((xDiff == 0 && yDiff > 0) || (xDiff == 0 && yDiff < 0)) {
			while (tempY < maxY && tempY >= 0) {
				if (boardState[tempX][tempY] != playerColor) {
					killStart=true;
					boardState[tempX][tempY] = 0;
					piecesKilled.add(new Point(tempX,tempY));
					if (isApproachMove) {
						tempX = tempX + xDiff;
						tempY = tempY + yDiff;
					} else {
						tempX = tempX - xDiff;
						tempY = tempY - yDiff;
					}
				} else if (boardState[tempX][tempY] == 0 && !killStart) {
					continue;
				} else {
					break;
				}
			}
		} else if ((yDiff == 0 && xDiff > 0) || (yDiff == 0 && xDiff < 0)) {
			while (tempX < maxX && tempX >= 0) {
				if (boardState[tempX][tempY] != playerColor) {
					boardState[tempX][tempY] = 0;
					killStart=true;
					piecesKilled.add(new Point(tempX,tempY));
					if (isApproachMove) {
						tempX = tempX + xDiff;
						tempY = tempY + yDiff;
					} else {
						tempX = tempX - xDiff;
						tempY = tempY - yDiff;
					}
				} else if (boardState[tempX][tempY] == 0 && !killStart) {
					continue;
				} else {
					break;
				}
			}
		} else if ((yDiff > 0 && xDiff > 0) || (yDiff < 0 && xDiff < 0)) {
			while (tempX < maxX && tempX >= 0 && tempY < maxY && tempY >= 0) {
				if (boardState[tempX][tempY] != playerColor) {
					boardState[tempX][tempY] = 0;
					if (isApproachMove) {
						tempX = tempX + xDiff;
						tempY = tempY + yDiff;
					} else {
						tempX = tempX - xDiff;
						tempY = tempY - yDiff;
					}
				} else if (boardState[tempX][tempY] == 0 && !killStart) {
					continue;
				} else {
					break;
				}
			}
		} else if ((yDiff < 0 && xDiff > 0) || (yDiff > 0 && xDiff < 0)) {
			
			while (tempX < maxX && tempX >= 0 && tempY < maxY && tempY >= 0) {
				if (boardState[tempX][tempY] != playerColor) {
					boardState[tempX][tempY] = 0;
					if (isApproachMove) {
						tempX = tempX + xDiff;
						tempY = tempY + yDiff;
					} else {
						tempX = tempX - xDiff;
						tempY = tempY - yDiff;
					}
				} else if (boardState[tempX][tempY] == 0 && !killStart) {
					continue;
				} else {
					break;
				}
			}
		}
	}
}
