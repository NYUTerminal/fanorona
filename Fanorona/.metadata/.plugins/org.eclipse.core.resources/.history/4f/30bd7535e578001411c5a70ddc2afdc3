package Logic;

import java.util.ArrayList;
import java.util.List;

public class Move {

	public int startPointX;
	public int startPointY;
	public int endPointX;
	public int endPointY;
	public int valueOfMove;

	final int BLACKPIECE = -1;
	final int WHITEPIECE = 1;
	final int EMPTYSPOT = 0;

	public Move(int startX, int startY, int endX, int endY) {

		startPointX = startX;
		startPointY = startY;
		endPointX = endX;
		endPointY = endY;
		valueOfMove = 0;
	}

	public Move() {

		startPointX = 0;
		startPointY = 0;
		endPointX = 0;
		endPointY = 0;
		valueOfMove = 0;
	}

	// Copy constructor
	public Move(Move other) {

		this.startPointX = other.startPointX;
		this.startPointY = other.startPointY;
		this.endPointX = other.endPointX;
		this.endPointY = other.endPointY;
		this.valueOfMove = other.valueOfMove;

	}

	public int[][] newMove(int[][] gameBoard) {
		// TODO Auto-generated method stub
		return null;
	}

	public boolean isOneStepMove() {
		int xDiff = endPointX - startPointX;
		int yDiff = endPointY - startPointY;
		if (-2 < xDiff && xDiff < 2 && -2 < yDiff && yDiff < 2)
			return true;
		
		return false;
	}
	
	public void killPiecesAndUpdateBoard(int[][] boardState, Move move,
			boolean isApproachMove, int colorToKill) {
		String typeOfKill;
		int xDiff = move.endPointX - move.startPointX;
		int yDiff = move.endPointY - move.startPointY;
		BoardProperties boardInstance = BoardProperties.getInstance();
		int maxY = boardInstance.getMAX_COL();
		int maxX = boardInstance.getMAX_ROW();
		// moved up and Approach or withdrawal capture.
		int playerColor = boardInstance.getPlayerColorInInt();
		int tempX = move.endPointX;
		int tempY = move.endPointY;
		List<Point> piecesKilled = new ArrayList<Point>();
		if (isApproachMove) {
			tempX = tempX + xDiff;
			tempY = tempY + yDiff;
		} else {
			tempX = tempX - xDiff;
			tempY = tempY - yDiff;
		}
		boolean killStart = false;
		if ((xDiff == 0 && yDiff > 0) || (xDiff == 0 && yDiff < 0)) {
			while (tempY < maxY && tempY >= 0) {
				if (boardState[tempX][tempY] != playerColor) {
					killStart = true;
					boardState[tempX][tempY] = 0;
					piecesKilled.add(new Point(tempX, tempY));
					if (isApproachMove) {
						tempX = tempX + xDiff;
						tempY = tempY + yDiff;
					} else {
						tempX = tempX - xDiff;
						tempY = tempY - yDiff;
					}
				} else if (boardState[tempX][tempY] == 0 && !killStart) {
					continue;
				} else {
					break;
				}
			}
		} else if ((yDiff == 0 && xDiff > 0) || (yDiff == 0 && xDiff < 0)) {
			while (tempX < maxX && tempX >= 0) {
				if (boardState[tempX][tempY] != playerColor) {
					boardState[tempX][tempY] = 0;
					killStart = true;
					piecesKilled.add(new Point(tempX, tempY));
					if (isApproachMove) {
						tempX = tempX + xDiff;
						tempY = tempY + yDiff;
					} else {
						tempX = tempX - xDiff;
						tempY = tempY - yDiff;
					}
				} else if (boardState[tempX][tempY] == 0 && !killStart) {
					continue;
				} else {
					break;
				}
			}
		} else if ((yDiff > 0 && xDiff > 0) || (yDiff < 0 && xDiff < 0)) {
			while (tempX < maxX && tempX >= 0 && tempY < maxY && tempY >= 0) {
				if (boardState[tempX][tempY] != playerColor) {
					killStart = true;
					boardState[tempX][tempY] = 0;
					piecesKilled.add(new Point(tempX, tempY));
					if (isApproachMove) {
						tempX = tempX + xDiff;
						tempY = tempY + yDiff;
					} else {
						tempX = tempX - xDiff;
						tempY = tempY - yDiff;
					}
				} else if (boardState[tempX][tempY] == 0 && !killStart) {
					continue;
				} else {
					break;
				}
			}
		} else if ((yDiff < 0 && xDiff > 0) || (yDiff > 0 && xDiff < 0)) {

			while (tempX < maxX && tempX >= 0 && tempY < maxY && tempY >= 0) {
				if (boardState[tempX][tempY] != playerColor) {
					boardState[tempX][tempY] = 0;
					killStart = true;
					piecesKilled.add(new Point(tempX, tempY));
					if (isApproachMove) {
						tempX = tempX + xDiff;
						tempY = tempY + yDiff;
					} else {
						tempX = tempX - xDiff;
						tempY = tempY - yDiff;
					}
				} else if (boardState[tempX][tempY] == 0 && !killStart) {
					continue;
				} else {
					break;
				}
			}
		}
		boardInstance.setBoardState(boardState);
	}

	
}
