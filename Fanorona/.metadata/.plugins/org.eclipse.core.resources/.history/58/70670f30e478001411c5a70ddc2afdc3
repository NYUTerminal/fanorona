package Logic;

import java.util.ArrayList;
import java.util.List;

public class AlphaBeta {

	// Comes AlphaBeta Logic .

	private Color playerColor;

	public static void main(String[] args) {

	}

	public void alphaBeta() {

	}

	public AlphaBeta(Color color) {
		this.playerColor = color;
	}

	public Move minimax(int[][] boardState) {
		int[][] nextGameState;
		int value, maxValue = Integer.MIN_VALUE;
		Move bestMove = new Move();

		ArrayList<Move> possibleMoveList = getValidMoves(boardState);
		if (possibleMoveList.size() != 0)
			bestMove = new Move(possibleMoveList.get(0));

		for (Move possibleMove : possibleMoveList) {
			nextGameState = (int[][]) boardState.clone();
			nextGameState = possibleMove.newMove(boardState);
			value = minMove(nextGameState, 5, maxValue, Integer.MAX_VALUE);
			if (value > maxValue) {
				// System.out.println ("Max value : " + value +
				// " at depth : 0");
				maxValue = value;
				bestMove = new Move(possibleMove);
			}
		}
		// System.out.println ("Move value selected : " + maxValue +
		// " at depth : 0");
		return bestMove;
	}

	static public int maxMove(int[][] gameState, int depth, int alpha, int beta) {
		Engine engine = new Engine();
		if (engine.checkGameOver(gameState) || depth <= 0)
			return engine.evaluateFunction(gameState);

		int[][] nextGameState;
		int value;
		ArrayList<Move> possibleMoveList = getValidMoves(gameState);

		// System.out.println ("Max node at depth : " + depth + " with alpha : "
		// + alpha + " beta : " + beta);

		for (Move possibleMove : possibleMoveList) {

			nextGameState = (int[][]) gameState.clone();
			nextGameState = possibleMove.newMove(gameState);

			value = minMove(nextGameState, depth - 1, alpha, beta);

			if (value > alpha) {
				alpha = value;
				// System.out.println ("Max value : " + value + " at depth : " +
				// depth);
			}

			if (alpha > beta) {
				// System.out.println ("Max value with pruning : " + beta +
				// " at depth : " + depth);
				return beta;
			}

		}

		// System.out.println ("Max value selected : " + alpha + " at depth : "
		// + depth);
		return alpha;
	}

	static public int minMove(int[][] gameState, int depth, int alpha, int beta) {
		Engine engine = new Engine();
		if (engine.checkGameOver(gameState) || depth <= 0)
			return engine.evaluateFunction(gameState);

		int[][] nextBoard;
		int value;
		ArrayList<Move> possibleMoveList = getValidMoves(gameState);

		// System.out.println ("Min node at depth : " + depth + " with alpha : "
		// + alpha + " beta : " + beta);

		for (Move possibleMove : possibleMoveList) {

			nextBoard = (int[][]) gameState.clone();
			nextBoard = possibleMove.newMove(gameState);
			value = maxMove(nextBoard, depth - 1, alpha, beta);

			if (value < beta) {
				beta = value;
				// System.out.println ("Min value : " + value + " at depth : " +
				// depth);
			}

			if (beta < alpha) {
				// System.out.println ("Min value with pruning : " + alpha +
				// " at depth : " + depth);
				return alpha;
			}
		}

		// System.out.println ("Min value selected : " + beta + " at depth : " +
		// depth);
		return beta;
	}

	private static ArrayList<Move> getValidMoves(int[][] gameBoard) {
		BoardProperties boardProperties = BoardProperties.getInstance();
		Color compColor = boardProperties.getCompColor();
		int compColorInt = (compColor.equals(Color.BLACK)) ? -1 : 1;
		List<Point> compPiecesPositions = new ArrayList<Point>();
		int maxCol = boardProperties.getMAX_COL();
		int maxRow = boardProperties.getMAX_ROW();
		for (int i = 0; i < maxCol; i++) {
			for (int j = 0; j < maxRow; j++) {
				if (gameBoard[i][j] == compColorInt) {
					compPiecesPositions.add(new Point(i, j));
				}
			}
		}
		List<Move> effectiveMoves = new ArrayList<Move>();
		List<Point> effectiveAdjPoints = new ArrayList<Point>();
		for (Point compPosition : compPiecesPositions) {
			List<Point> adjPoints = Point.getAdjPoints(compPosition);
			for (Point adjPoint : adjPoints) {
				if (gameBoard[adjPoint.getX()][adjPoint.getY()] == 0 ) {
					effectiveAdjPoints.add(adjPoint);
					effectiveMoves.add(new Move());
				}
			}
		}
		return null;
	}
}
