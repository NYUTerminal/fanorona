package Logic;

public class Engine {

	private int MAX_ROW;
	private int MAX_COL;
	private int row;
	private int col;
	private Color playerColor = Color.BLACK;
	private final int smallBoard = 3;
	private final int largeBoard = 5;
	private int[][] boardState;

	public Engine() {
		this.MAX_ROW = 0;
		this.MAX_COL = 0;
		this.row = 0;
		this.col = 0;

	}

	public Color getOtherColor(String input) {
		if (input.equals(Color.WHITE))
			return Color.BLACK;
		else
			return Color.WHITE;
	}

	public void initializeBoard(int sizeOfBoard, String playerColor) {
		BoardProperties bP = BoardProperties.getInstance();
		if (sizeOfBoard == 1) {
			this.MAX_COL = smallBoard;
			this.MAX_ROW = smallBoard;
			bP.setMAX_COL(smallBoard);
			bP.setMAX_ROW(smallBoard);
			bP.setCompColor(getOtherColor(playerColor));
			bP.setPlayerColor(getOtherColor(bP.getCompColor().toString()));

		} else {
			this.MAX_COL = largeBoard;
			this.MAX_ROW = largeBoard;
			bP.setMAX_COL(largeBoard);
			bP.setMAX_ROW(largeBoard);
			
		}
		if (playerColor.equals(Color.WHITE)) {
			this.playerColor=Color.WHITE;
			bP.setCompColor(getOtherColor(playerColor));
			bP.setPlayerColor(Color.WHITE);
		}else{
			bP.setCompColor(getOtherColor(playerColor));
			bP.setPlayerColor(Color.BLACK);
		}
		boardState = new int[MAX_ROW][MAX_COL];
		boolean flip = false;
		for (int i = 0; i < MAX_ROW; i++) {
			for (int j = 0; j < MAX_COL; j++) {
				if (i < (MAX_ROW / 2)) {
					boardState[i][j] = +1;
				} else if (i > (MAX_ROW / 2)) {
					boardState[i][j] = -1;
				} else if (i == MAX_ROW / 2 && i != j && flip) {
					boardState[i][j] = -1;
					if (flip)
						flip = false;
					else
						flip = true;
				} else if (i != j) {
					boardState[i][j] = +1;
				} else {
					boardState[i][j] = 0;
				}
			}
		}
	}

	public int evaluateFunction(int[][] gameState) {
		int value = 0;

		for (int x = 0; x < MAX_ROW; x++) {
			for (int y = 0; y < MAX_COL; y++) {
				if (gameState[x][y] == 1)
					value++;
				if (gameState[x][y] == -1)
					value--;
			}
		}
		return value;
	}

	public boolean checkGameOver(int[][] boardState) {
		int blackPieces = 0;
		int whitePieces = 0;
		for (int i = 0; i < this.MAX_ROW; i++) {
			for (int j = 0; j < this.MAX_COL; j++) {
				if (boardState[i][j] == -1) {
					blackPieces++;
				} else if (boardState[i][j] == +1) {
					whitePieces++;
				}
			}
		}
		if (whitePieces == 0 | blackPieces == 0) {
			return true;
		} else
			return false;

	}

	private void placePiecesOnBoard() {

	}

	public static void main(String[] args) {
		Engine e = new Engine();
		System.out.println(e.MAX_COL);

	}

	public int[] getAllPossiblePositions() {

		return null;

	}

	public void printCurrestStateOfBoard() {
		for (int i = 0; i < MAX_ROW; i++) {
			for (int j = 0; j < MAX_COL; j++) {
				System.out.print(boardState[i][j]);
			}
			System.out.println("\n");
		}
	}

	public int[][] makeAMove(Color playerColor, Move move) {
		if (move.isOneStepMove()) {
			// Kill computer pieces and apply alpha beta.

			AlphaBeta ab = new AlphaBeta(playerColor);
			Move minimax = ab.minimax(boardState);
			return updatedBoard(boardState, minimax, playerColor);
		} else {
			System.out.println("Invalid Move Dude!!");
		}

		return null;
	}

	private int[][] updatedBoard(int[][] boardState, Move minimax,
			Color playerColor) {
		boardState[minimax.startPointX][minimax.startPointY] = 0;
		if (playerColor.equals(Color.BLACK))
			boardState[minimax.endPointX][minimax.endPointY] = -1;
		else
			boardState[minimax.endPointX][minimax.endPointY] = +1;
		// TODO Auto-generated method stub
		return boardState;
	}

}
