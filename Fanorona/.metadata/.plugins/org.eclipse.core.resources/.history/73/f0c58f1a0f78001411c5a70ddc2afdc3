package Logic;

import Move;

import java.util.ArrayList;

public class AlphaBeta {

	// Comes AlphaBeta Logic .

	private int[][] gameState;

	public static void main(String[] args) {

	}

	public void alphaBeta() {

	}

	public AlphaBeta() {

	}
	
	public FanonaraState makeAMove() {
		int alpha = Integer.MIN_VALUE;
		int beta = Integer.MAX_VALUE;
		int bestScore = -Integer.MAX_VALUE;

		Piece p = new Piece();
		GameState bestMove = null;
		for (GameTreeNode child : gameTreeRoot.getChildren()) {
			if (bestMove == null) {
				bestMove = child.getState();
			}
			alpha = Math.max(alpha, miniMax(child, plyDepth - 1, alpha, beta));
			if (alpha > bestScore) {
				bestMove = child.getState();
				bestScore = alpha;
			}
		}
		return bestMove;

		return null;

	}

	public Move minimax(int[][] boardState) {
		int[][] nextBoard;
		int value, maxValue = Integer.MIN_VALUE;
		Move bestMove = new Move();

		ArrayList<Move> possibleMoveList = getValidMoves(boardState);
		if (possibleMoveList.size() != 0)
			bestMove = new Move(possibleMoveList.get(0));

		for (Move possibleMove : possibleMoveList) {
			nextBoard = (int[][]) boardState.clone();
			nextBoard = possibleMove.newMove(boardState);
			value = minMove(nextBoard, 5, maxValue, Integer.MAX_VALUE);
			if (value > maxValue) {
				// System.out.println ("Max value : " + value +
				// " at depth : 0");
				maxValue = value;
				bestMove = new Move(possibleMove);
			}
		}
		// System.out.println ("Move value selected : " + maxValue +
		// " at depth : 0");
		return bestMove;
	}

	private static ArrayList<Logic.Move> getValidMoves(int[][] gameBoard) {
		// TODO Auto-generated method stub
		return null;
	}

	static public int maxMove(int[][] gameState, int depth, int alpha, int beta) {
		Engine engine = new Engine();
		if (engine.checkGameOver(gameState) || depth <= 0)
			return engine.evaluateBoard(gameState);

		int[][] nextBoard;
		int value;
		ArrayList<Move> possibleMoveList = getValidMoves(gameState);

		// System.out.println ("Max node at depth : " + depth + " with alpha : "
		// + alpha + " beta : " + beta);

		for (Move possibleMove : possibleMoveList) {

			nextBoard = (int[][]) gameState.clone();
			nextBoard = possibleMove.newMove(gameState);

			value = minMove(nextBoard, depth - 1, alpha, beta);

			if (value > alpha) {
				alpha = value;
				// System.out.println ("Max value : " + value + " at depth : " +
				// depth);
			}

			if (alpha > beta) {
				// System.out.println ("Max value with pruning : " + beta +
				// " at depth : " + depth);
				return beta;
			}

		}

		// System.out.println ("Max value selected : " + alpha + " at depth : "
		// + depth);
		return alpha;
	}

	static public int minMove(int[][] gameBoard, int depth, int alpha, int beta) {

		if (gameOver(gameBoard) || depth <= 0)
			return evaluateBoard(gameBoard);

		int[][] nextBoard;
		int value;
		ArrayList<Move> possibleMoveList = getValidMoves(gameBoard);

		// System.out.println ("Min node at depth : " + depth + " with alpha : "
		// + alpha + " beta : " + beta);

		for (Move possibleMove : possibleMoveList) {

			nextBoard = (int[][]) gameBoard.clone();
			nextBoard = possibleMove.newMove(gameBoard);
			value = maxMove(nextBoard, depth - 1, alpha, beta);

			if (value < beta) {
				beta = value;
				// System.out.println ("Min value : " + value + " at depth : " +
				// depth);
			}

			if (beta < alpha) {
				// System.out.println ("Min value with pruning : " + alpha +
				// " at depth : " + depth);
				return alpha;
			}
		}

		// System.out.println ("Min value selected : " + beta + " at depth : " +
		// depth);
		return beta;
	}

}
