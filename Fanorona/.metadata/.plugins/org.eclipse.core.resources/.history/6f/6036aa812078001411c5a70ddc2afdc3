package Logic;

import java.util.ArrayList;
import java.util.List;

public class Move {

	public int startPointX;
	public int startPointY;
	public int endPointX;
	public int endPointY;
	public int valueOfMove;

	final int BLACKPIECE = -1;
	final int WHITEPIECE = 1;
	final int EMPTYSPOT = 0;

	public Move(int startX, int startY, int endX, int endY) {

		startPointX = startX;
		startPointY = startY;
		endPointX = endX;
		endPointY = endY;
		valueOfMove = 0;
	}

	public Move() {

		startPointX = 0;
		startPointY = 0;
		endPointX = 0;
		endPointY = 0;
		valueOfMove = 0;
	}

	// Copy constructor
	public Move(Move other) {

		this.startPointX = other.startPointX;
		this.startPointY = other.startPointY;
		this.endPointX = other.endPointX;
		this.endPointY = other.endPointY;
		this.valueOfMove = other.valueOfMove;

	}

	public int[][] newMove(int[][] gameBoard) {
		// TODO Auto-generated method stub
		return null;
	}

	public boolean isOneStepMove(){

		return false;
	}
	
	public List<Point> getAdjPoints(Point currentPoint,int maxRow,int maxCol){
    	List<Point> adjacentPoints = new ArrayList<Point>();
    	adjacentPoints.add(new Point(currentPoint.x, currentPoint.y + 1));
		adjacentPoints.add(new Point(currentPoint.x, currentPoint.y - 1));
		adjacentPoints.add(new Point(currentPoint.x + 1, currentPoint.y));
		adjacentPoints.add(new Point(currentPoint.x - 1, currentPoint.y));
        //diagonals
        if(isDiagonalMovesPossible(currentPoint)) {
            adjacentPoints.add(new Point(currentPoint.x + 1, currentPoint.y + 1));
            adjacentPoints.add(new Point(currentPoint.x + 1, currentPoint.y - 1));
            adjacentPoints.add(new Point(currentPoint.x - 1, currentPoint.y + 1));
            adjacentPoints.add(new Point(currentPoint.x - 1, currentPoint.y - 1));
        }
        
        for(Point p : adjacentPoints){
        	if(!p.isValidPoint(maxRow,maxCol)){
        		
        	}
        }
        return adjacentPoints;
	}
	
     private Boolean isDiagonalMovesPossible(Point currentPoint) {//{{{
        //(odd,odd) or (even,even)
        return (currentPoint.x % 2 == 1 && currentPoint.y % 2 == 1) || (currentPoint.x % 2 == 0 && currentPoint.y %2 == 0);
    }
}
